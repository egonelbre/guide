<html><head><title>A Guide to ...</title><link rel='stylesheet' href='assets/main.css'></head><body><section>
	<h0>A Guide To Programming</h0>
	<figure><img class="book-title" src="assets/hiking.png"></figure>

	<toc>
		<section>
	<h1>Intro</h1>

	<toc>
		<section>
	<h2>Why?</h2>

	<div class="quote"><div class="text">There is one timeless way of building. It is a thousand years old, and the same today as it has ever been. The great traditional buildings of the past, the villages and tents and temples in which man feels at home, have always been made by people who were very close to the center of this way.</div><div class="by">Christopher Alexander</div></div>

	<p><ul>
		<li>What is the timeless way of building programs?</li>
		<li>What makes programs beautiful?</li>
		<li>How do you create programs from nothing?</li>
		<li>How do you ensure that the program architecture is beautiful?</li>
	</ul></p>

	<p>This book guides you through building several programs from start to deployment. It is meant to give insight how to incrementally develop architecture without big upfront investment. Hopefully, it will also provide some insight into the questions asked previously.</p>

	<p>During programming it is very easy to get lost in all the small implementation details. Then again, when looking at the large picture, it is easy to miss small important details. These views must be balanced and treated equally, otherwise the code will suffer.</p>

	<p>This introduction will describe the general process and terminology that will be used throughout the book.</p>
</section>
		<section>
	<h2>Premise</h2>

	<div class="quote"><div class="text">It's not for you Jen.</div><div class="by">IT Crowd</div></div>

	<p>Obviously, no book is perfect for everyone, so it helps to clarify what is expected from the reader.</p>

	<p>First, you should be familiar with programming. It is not necessary that you have written a big program, however it could help you to understand the issues better.</p>

	<p>Second, you should be able to search and learn the necessary implementation details on your own. For example, when the book requires the use of HTML, the reader should go and learn about it. It will go into technical details only when it is necessary.</p>

	<p>Third, this book uses Go, but the same principles apply to any language. The building process is the constant between languages, although the implementation details can vary significantly. If you are not familiar with Go then please learn the basics before proceeding.</p>

	<p>Throughout this book we will be doing many decisions that may not make the best business sense. For example, you shouldn't start building a issue tracker unless you have a clear ROI in mind. We may make decisions that you disagree with, these are not the important part in this book. These decisions are made during development when we don't know full information on what problems will come ahead. There will be decisions that could have made our lives easier or used a better library and so on... but this is the reality of programming: you won't make the best decisions every time.</p>
</section>
		<section>
	<h2>Value</h2>

	<div class="quote"><div class="text">... starting in The Mist, you are seeking ways to create Value, where value is defined as something of worth to some person or set of people whom we wish to serve.</div><div class="by"><a href="https://sites.google.com/a/scrumplop.org/published-patterns/value-stream">Value Stream - ScrumPLOP</a></div></div>

	<p>Why do we write programs in the first place?</p>

	<p>Obviously we want to provide <ix>value</ix> to people, not waste. This is why <ix>value</ix> is so important, it helps us ground in search for solutions. It helps us understand why we are doing things in the first place. If you are not creating something of <ix>value</ix> then you are creating waste.</p>

	<section>
		<h3>Valuable</h3>

		<p>To understand <ix>value</ix> we must first understand why do we call things <ix>valuable</ix>.</p>

		<p>In the simplest terms when <c>X</c> is <ix>valuable</ix> to someone <c>Y</c> it means, that <c>X</c> has importance to <c>Y</c>, it can bring benefit to <c>Y</c> in some way.</p>

		<p>This is not rocket science:
			<ul>
				<li>the internet is valuable because it can connect people to information with very little cost,</li>
				<li>a keyboard is valuable because it allows to interact with the computer and</li>
				<li>an text editor is valuable because it allows to modify and adjust text with ease.</li>
			</ul>
		</p>

		<p>We know and feel when something is valuable to us and we can emphatize when something is valuable to someone else. We should embrace this inner feeling and let it guide us.</p>
	</section>

	<section>
		<h3>The Context</h3>

		<p>However, understanding <ix>value</ix> is not that easy. We must always bear in mind that the <ix>value</ix> something possesses is deeply tied in the context where it exists.</p>

		<ul>
			<li>If there isn't information on the internet, then it's not as valuable.</li>
			<li>If there is no computer for the keyboard, then the keyboard is not useful.</li>
			<li>If you have nothing to write, then a text editor is not valuable.</li>
		</ul>

		<p>This is all common sense, but these examinations help us examine more important questions. Let's take something more difficult.</p>

		<p><i>Does 'logging in to a system' have value?</i> First reaction would be to say, <i>"Yes, of course it does.?"</i> But, have you ever said, <i>"I got so much value from logging in to the system?"</i> I doubt it. Should we conclude that <i>"No, of course logins have no value, they are only an annoyance?"</i></p>

		<p>As you may have already guessed, neither answer is correct. The goal of "logging in" is to protect <ix>value</ix>, rather than to be of <ix>value</ix>. If there is no login screen for a system that you don't use, then it is not of importance to you. When it's a online bank login, the login is as valuable to you, as how much money you have on your accounts. For the banks the login system is very important, although it may not be of any value.</p>

		<p>It's not as simple as <i>"Does login have value?"</i>, the <ix>value</ix> of something will be deeply tied to where it happens.</p>
	</section>

	<section>
		<h3>Evaluator</h3>

		<p>You should also have noticed that the value will also depend on who is doing the evaluating. We have to keep in mind that there is always a evaluator when looking at value.</p>

		<p>When creating value we should always look through the eyes of the person that we are creating the value for. And the person we provide value for can change. Let's say we are building a wooden-box.</p>

		<p>In the simplest case we are providing value for the end-user. You make a wooden-box and the end-user uses it.</p>

		<ul>
			<li>We could provide value to some other person in your team. You cut few boards and give them to another person to assemble. The end-user really doesn't care about those boards, they are not valuable to him.</li>
			<li>We could provide value to ourselves. I make a jig that allows me to cut boards faster and with less effort. Neither the person doing the assembly or end-user won't care about the jig.</li>
			<li>All of these things help to provide value to the end-user. It is something that we must keep in our minds, value helps to create <ix>value</ix>.</li>
		</ul>

		<p>We shouldn't restrict our minds to creating "boxes", but rather see the bigger picture. How is the box valuable to the end-user, how will he use it. Does he hold very lightweight things there - this means we can make the box sides thinner and reduce waste. Does he use different things there, maybe we can add separators into the box.</p>

		<p>Understanding what is created and why things are valuable to people is essential to making good decisions, in general.</p>
	</section>

	<section>
		<h3>Outside the box</h3>

		<p>We should have a bigger view and understand that we can get same value from multiple solutions. Engineering is about understanding those different solutions and deciding which is the most appropriate.</p>

		<p>When we look at the "logging in to a system" case. If the data can be public, then we won't need a login. Are we only using it on our own computer, no login necessary. Are we only using it from within a intranet, no login necessary.</p>

		<p>Look for multiple solutions, you can avoid a lot of work this way.</p>
	</section>
	<section>
		<h3>Decisions</h3>

		<p>Value will be at the core at our decision making, it helps to give us clarity why we are doing something and not doing something else. Always understand what the <ix>value</ix> is for the end-user, because there all the things built must come together.</p>

		<p>All of this talk about <ix>value</ix> may seem fluffy, but we will soon put all this understanding to the test.</p>
	</section>
</section>



		<section>
	<h2>Building</h2>

	<div class="quote"><div class="text">Speaking as a builder, if you start something, you must have a vision of the thing which arises from your instinct about preserving and enhancing what is there... If you're working correctly, the feeling doesn't wander about.</div><div class="by">Christopher Alexander</div></div>

	<p>The most important part of programming is that you cannot do everything at once. The human mind is fairly limited how much it can hold in its head at a time. To combat this limitation we need to build things piece-by-piece to ensure that everything will fit together nicely.</p>

	<p>Following patterns are invaluable to building something with ease and clearity.</p>

	<section>
		<h3>Structure Follows Value</h3>

		<p>We dedicated a lot of time explaining what value is and why it is important. To ensure that we actually build something of value, we need to understand the value it provides and how it provides it.</p>

		<p>By dissecting and deconstructing value we are able to find boundaries that align with the problem domain.</p>
	</section>

	<section>
		<h3>Spiking</h3>

		<p>To ensure that we get a good global view how things will interact we put up several spikes and imagine everything working together. This helps to iterate much faster on the larger view without being slowed down by techinical details.</p>
	</section>

	<section>
		<h3>Gradual Stiffening</h3>

		<p>To accomodate all the issues that arises from integrating different pieces we gradually make the code more solid. This allows better detection on any problems that may arise.</p>
	</section>

	<section>
		<h3>Cleanup</h3>

		<p>This always happens in tandem with gradual stiffening and should be done to finish that everything is correct and in order.</p>
	</section>

	<section>
		<h3>Putting them together</h3>


		<p>It might not be easy to comprehend this without practical examples, but the easiest way to understand is to imagine this with drawing.</p>

		<p><ul>
			<li>You don't start drawing from the top-left corner and proceed to the right</li>
			<li>side, and then the next line. First you figure out, what you are drawing</li>
			<li>and what are the things you are going to draw (structure follows value).</li>
			<li>Then you do few rough sketches until you see that the drawing will work nicely (spiking).</li>
			<li>Then you start to refine the sketches, then you draw properly with a pen (gradual stiffening).</li>
			<li>Then you clean all the sketch lines and color it (cleanup).</li>
		</ul></p>

		<p>The basic pattern of programming is the same.</p>
	</section>
</section>
	</toc>
</section>
		<section>
	<h1>Issue Tracker</h1>

	<p>Our first case study will be an <b>issue tracker</b>. Probably you have seen one and use one, that way it will be easy to discuss. The code for this project can be found at <span class="link" href="http://github.com/loov/tracker">github.com/loov/tracker</span>.</p>

	<p>Since we already stated that <sym>value</sym> will be very dependent on the <sym>context</sym>. So, here is our facilitated situation:
		<description>There is a company of 40 people and contains 8 teams. Some problems inside teams take too much time to solve and there is no proper visibility on the issues that the team must solve. When a issue moves from person to person and team to team there is no direct knowledge how much has been done.</description>
	</p>

	<p>Scrum suggests that a <span class="link" href="https://sites.google.com/a/scrumplop.org/published-patterns/product-organization-pattern-language/development-team">Development Team</span> must work as one unit instead of single individuals to achieve the best performance. Many issue trackers take the other approach, an issue is assigned to a specific person. Our goal will be to create an issue tracker that handles only teams.</p>

	<p>Of course, you may not disagree with this goal, but nevertheless it serves as a good starting point for implementing something new. Going forward, there can be many decisons about value and importance that you may not agree with. It is fine to disagree with these points, they are there because we need some decision to go forward with the implementation.</p>

	<toc>
		<section>
	<h2>An Issue</h2>
	<p>Here is our first important question. <hypothetical>"What provides value in an Issue Tracker?"</hypothetical></p>

	<p>We may notice the important pieces from the language used.
		<ul>
			<li>What are we working on?</li>
			<li>I need to finish this issue.</li>
			<li>I don't have good visibility on the issues.</li>
		</ul>
	</p>

	<p>We may also get this information from a domain expert. In our case it is obvious, the most important thing is an <ix>issue</ix>.</p>

	<p>Here we should think, why <ix>issue</ix> is important:
		<ul>
			<li>It shows what we are doing.</li>
			<li>It shows what we have done.</li>
			<li>It shows what we still need to do.</li>
		</ul>
	</p>

	<p><ix>Issue</ix> is definitely a valuable part of Tracker hence we must capture it in code.</p>

	<section>
		<h3>Contain it</h3>
		<vcs repo="https://github.com/loov/tracker/" sha="bd9af4dcda0207555204bad0addcd0ce4d0a61dc"></vcs>

		<p>To ensure that we can capture <ix>issue</ix> and do not lose the knowledge about it's importance we should create a namespace for it. That way we make it significant and important. At the same time we create a locus of attention which allows to understand and examine the feature wholly and whether it is complete.</p>

		<p>Of course, namespaces are not the only way to contain things - there are also packages, classes, functions, methods, constraints etc. What you use to contain will depend on how large, detailed or important the contained thing is.</p>

		<p>It is better to start with a notch larger container than is needed, it is not difficult to make it smaller. However the reverse, moving from smaller container to larger, is usually more difficult.</p>

		<p><ix>Issue</ix> is a very important concept, hence we start with a package <c>issue</c>. Our starting folder structure will be:
			<figure><pre>/main.go #1#
/issue/
</pre></figure></p>
		<p>It is clear that at somepoint we will need <file at="1">main.go</file>, so we can add it now - although, when we add it doesn't matter.</p>
	</section>

	<section>
		<h3>Spike it</h3>
		<vcs repo="https://github.com/loov/tracker/" sha="9f47cfaaeadbaa999dc36fd238684151bb9bc6e4"></vcs>

		<p>We should try to figure out what our <c>issue</c> contains. Create <file>issue/info.go</file> with:</p>
		<figure><pre>package issue

type ID int                     //#1#
type Status string              //#2#

const (
	Created Status = &#34;Created&#34;  //#3#
	Closed         = &#34;Closed&#34;
)

type Info struct {              //#4#
	ID      ID
	Caption string
	Desc    string
	Status  Status
}
</pre><div class="caption">issue/info.go</div></figure>

		<p>We must have an <c at="1">issue.ID</c> to uniquely identify an issue. Each issue usually has an <c at="2" at="3">issue.Status</c> associated with it. We need something to bring all the attributes together <c at="4">issue.Info</c>. Keep in mind we are sketching the code and are not committed to this structure. We are not looking perfection, but rather a global view how things will work together.</p>

		<sidenote><p>Notice that I don't use long names such as <c>IssueStatus</c>, <c>IssueInfo</c> because the namespace for them already contains name <c>issue</c>. We should always leverage our namespace for naming. The full name for them are <c>issue.Status</c> and <c>issue.Info</c> which help to clarify.</p></sidenote>

		<p>We also need some way to store and load those issues. The way we store and load
		them can change, hence we should abstract this knowledge away. We create an
		interface <c>issue.Manager</c> for it. We put it into <file>issue/manager.go</file>:
			<figure><pre>package issue

type Manager interface {
	Create(info Info) (ID, error)
	Load(id ID) (Info, error)
	Close(id ID) (error)
	List() (issues []Info, error)
}
</pre><div class="caption">issue/manager.go</div></figure>
		</p>

		<p>To get a overview how we will use it, we write some usage code into <file>main.go</file></p>

		<figure><pre>package main

import (
	&#34;fmt&#34;

	&#34;github.com/loov/tracker/issue&#34;
)

func check(err error) {
	if err != nil {
		panic(err)
	}
}

func main() {
	c manager issue.Manager

	id, err := manager.Create(issue.Info{
		Caption: &#34;Hello&#34;,
		Desc: &#34;World&#34;,
		Status: issue.Created,
	})
	check(err)

	info, err := manager.Load(id)
	check(err)

	fmt.Println(info)

	infos, err := manager.List()
	check(err)
	fmt.Println(infos)
}
</pre><div class="caption">main.go</div></figure>

		<p>It doesn't matter in which order you create these pieces, sometimes it is easier to create the usage code first, other times it is easier to create the implementation first. The thing that does matter is that both exist to ensure that we have the implementation details right and that we can integerate it with rest of the code.</p>

		<p>The usage code can also be sketched as a test, this depends on how the sketched code will be used, how it needs to integerate with the rest of the system and other factors.</p>
	</section>

	<section>
		<h3>Gradual stiffening</h3>

		<p>Notice that we actually don't have any runnable code yet, it's fine, because until now we were trying to grasp what we are implementing and that all the pieces work together as intended.</p>

		<p>Now we will step-by-step start to flesh out the actual structure, until we have solid and good runnable code. We are in our beginning stages of our project so there really isn't much to worry about. We should skim over our code and notice anything that doesn't feel nice.</p>

		<p>The first thing we may notice is <c>issue.Created</c>. What would <c>info.Status == issue.Created</c> mean? This suggests that we haven't captured the intent as well as we should have. Let's refine our sketch, <c>info.Status == issue.Open</c> sounds much better, hence we change <file>issue/info.go</file>:</p>

		<figure><pre>const (
	Open Status = &#34;Open&#34;
	Done        = &#34;Done&#34;
)
</pre><div class="caption">issue/info.go</div></figure>

		<p>In <file>main.go</file> the <c>manager</c> doesn't feel solid, it feels like a fuzzy concept
		without specific meaning. There probably will be more things that need to "manage"
		things. Is there a better name for it?</p>

		<p>What does the <c>manager</c> do? <thought>"It manages and tracks issues."</thought> Here is a clue for a nicer name <c>Tracker</c>. We shall refine <file>issue/manager.go</file> into <file>issue/tracker.go</file> and change:
			<figure><pre>package issue

type Tracker interface {
	Create(info Info) (ID, error)
	Load(id ID) (Info, error)
	Close(id ID) (error)
	List() (issues []Info, error)
}
</pre><div class="caption">issue/tracker.go</div></figure>
		</p>

		<p>We also do all the necessary adjustments to <file>main.go</file>. At the end of this we should have code that compiles however it's fine if it is not yet completely bug-free. We will do this in the next step, however gradual stiffening together with cleanup should be mixed it will always end with a final cleanup pass.</p>
	</section>

	<section>
		<h3>Cleanup</h3>
		<vcs repo="https://github.com/loov/tracker/" sha="56f7a0930c1715deeef9e1cf18924353d4968d44"></vcs>

		<p>Now we have a good idea about the feature and how to put it into code, we shall go over and fill in all the missing details and ensure that we have comments and a few tests and are able to use it in some form.</p>

		<p>Here we add a stub implementation for the tracker and then write some tests for the tracker.</p>

		<p><b>Cleanup code</b> means now that you have figured out the sketch, you can go and trace over it with nice clean looking lines, using the ruler and delete all the messy bits.</p>

		<p>The other thing what we want to do here is to make easier to understand and ensure whether the code really behaves as it should. In most cases you would want unit or behavior tests, but they are not the only way. You could also write property tests. Or write output that could be verified by hand, if the correct behavior is difficult to describe in code.</p>

		<p>Few interesting bits while solidifying code. When you come across questions, mark them as such. For example while writing the tracker test case, I made a mistake while writing:
			<figure><pre>tracker.Close(id)
// ...
expect := Info{
	ID:      id,
	Caption: &#34;Caption&#34;,
	Desc:    &#34;Desc&#34;,
	Status:  Closed,     // compilation error, should be Done
}
</pre><div class="caption">issue/tracker_test.go</div></figure>
		</p>

		<p>I mixed up two things: the method is called <c>Close</c> and the resulting status is <c>Done</c>. Because I made a mistake while writing this, it suggests to me that the code is not clear enough... but I'm not sure how to improve it. It probably isn't that important, so I'll mark it as a <b>TODO</b> and move on to other things:
			<figure><pre>const (
	//TODO: should tracker.Create renamed to &#34;Open&#34;, because status is Open
	Open = Status(&#34;Open&#34;) // Open means that the issue needs to be worked on
	//TODO: should &#34;Done&#34; be renamed to &#34;Closed&#34;, because tracker has method Close
	Done = Status(&#34;Done&#34;) // Done means that the issue is completed and delivered
)
</pre><div class="caption">issue/info.go</div></figure>
		</p>

		<p>I could try to figure out this immediately, but I really don't think I have necessary information right now and I will probably find out the details while implementing other things.</p>
	</section>

	<section>
		<h3>Is it done?</h3>

		<p>Now we have captured something of value in code. It can't be used easily right now, but we have something that someone would like to use.</p>

		<p>It might look that it was a really involved process that created only these few lines of code. In reality, it's pretty fluid and moves quite quickly. The only reason it looks involved is because I tried to write down everything I was thinking while writing the code.</p>
	</section>
</section>
	</toc>
</section>
		<section>
	<h1>Timeclock</h1>

	<p>I was asked how difficult it would be to implement a something to show project progress for a welding company. I thought it would be a great case-study.</p>

	<p>In the <span class="link" src="../issue-tracker/index.xml">Issue Tracker</span> we took things very slow to show the ideas behind building something. Here we will try to go at full speed. How much you can do at the same time will depend on your skill level and previous knowledge of the domain. The code for this project can be found at <span class="link" href="http://github.com/loov/timeclock">http://github.com/loov/timeclock</span></p>

	<toc>
		<section>
	<h2>The Discussion</h2>

	<p>Here's the translated chat about the project:</p>

	<transcript C="Customer" A="Analyst">
		<C>Hi, how difficult would it to make a webpage where
	   workers can login and add worked hours to different
	   projects plus any materials that were used and have
	   an option to add pictures.</C>
		<A>It depends how much different things are added. It shouldn't be too difficult, probably there already exist things that do that.</A>
		<C>Yes, there is, it costs about ~150€ per month for single user, also they don't solve our problems very well. I asked the pricing for some 20 users, it was ~6000€.</C>
		<A>If there isn't any complicated business problems and there is no need for old browser support, then it should be fairly simple.</A>
		<C>Wait I'll make a quick diagram, how it should work.</C>

		<figure><img src="programming/timeclock/images/project-sketch.png"></figure>

		<C>Every user gets a login user and password. Only supervisor can change things.</C>
		<A>Do you need any summary/statistics pages?</A>
		<C>Yes, that would be useful.</C>

		<wait></wait>

		<A>Who will create the projects?</A>
		<C>The supervisor.</C>
		<A>What information needs to be associated with each project?</A>
		<C>If it's a project with fixed pricing then it calculates how much has been spent and whether balance is positive or negative.</C>

		<wait></wait>

		<A>How will the balance be calculated?</A>
		<C>Hours and materials.</C>
		<A>Does every worker have the same hour cost? Or does it vary between projects?</A>
		<C>Usually the cost per hour is same, except workshop hours.</C>
		<A>Always or usually?</A>
		<C>For different orders it can be different. You should be able to change the pricing.</C>

		<wait></wait>

		<A>Can the whole thing be in English or does it need to be localized?</A>
		<C>Translation is a small problem.</C>
		<A>It's not about the translating part, rather whether there should be built-in support for multiple languages.</A>

		<wait></wait>

		<A>How should changing pricing look like? Should it need some default values that will be used and can be overridden depending on the project? Will they change during project?</A>
		<C>The pricing will be fixed when the project is created and won't be changed later.</C>

		<wait></wait>

		<A>Do you need something for sub-projects or sub-tasks?</A>
		<C>Yes, that might come in handy.</C>
		<A>Do you need multi-level or is a two-level separation sufficient? Project -&gt; Objective X -&gt; Task A; or Project -&gt; Objective A.</A>
		<C>Two-level separation would be sufficient.</C>

		<wait></wait>

		<A>How will the worker mark down material usage? By price, amount or something else?</A>
		<C>When project is created then the material usage is already known. But worker should be able to say that instead of 4 bolts we actually needed 6.</C>
		<A>So will he write: 2 bolts priced at 8€ per piece, or 2 bolts, type XYZ and get the price from system?</A>
		<C>Yup, the latter one.</C>

		<wait></wait>

		<A>Can the bolt price change during the project and how should it be handled, let's say there is:
			<ol>
				<li>In a project it's marked that 2 bolts were used.</li>
				<li>Then price of that bolt changes.</li>
			</ol> Should the price be considered at 1. or 2.</A>
		<C>At moment 1.</C>

		<wait></wait>

		<A>How does the worker mark down his status? "I worked on X for 4hours?" How should the work hour pricing be calculated? Does it have to be legally valid from an accounting standpoint or is it only for internal tracking?</A>
		<C>For workers we only track the hours, accounting manages the payments separately. Important are materials and cost per hour.</C>
   </transcript>

   <p>This whole discussion took about 1hour. This seems like
a lot of jumping around instead of a rigid discussion, but
it conveys sufficient information about the project to
make a prototype.</p>

	<section>
		<h3>Artifacts</h3>

		<p>While discussing I was simultanously desiging different artifacts that need to be tracked:</p>

		<figure><pre>ResourceType (Worker, Material)

[]Resource {
	Name
	ResourceType
	Unit
	UnitPrice
}

Unit (Hour, Piece, Grams, Litre)

Customer {
	Name
	Phone
}

Worker {
	Name
	Supervisor
}

Project {
	Customer
	Title
	Pricing {
		Hours
		Price
	}
	Status
	Description
}

Task {
	Project
	Title
	Description
}

Expense {
	Project
	Task
	Worker
	Date
	Resource
	Amount
	Unit
	UnitPrice
}

Comment {
	Task
	Worker
	Date
	Comment
}

Attachment {
	Task
	Worker
	Date
	Comment
}
</pre></figure>

		<p>This isn't some magic syntax, it's pseudo-code of artifacts. Here I decided to track work-hours and materials as "Expense" instead of separate entities, it will add some uniformity to the discussion.</p>
	</section>

	<section>
		<h3>Prototype</h3>

		<p>I'm sure that we don't have full understanding of the business logic, but we do understand how things are related. It will be sufficient to create a prototype.</p>

		<p>Note, that it is a concious desicion to stop analysis at this point. This is the minimal viable product that provides value to the customer. I'm not sure whether customer would be to imagine all the intricacies even if I asked them. I might get wrong or guesses instead of good answers. We need something solid, something that the customer can try out.</p>

		<p>There are several ways we could build the prototype: paper mock-ups, wireframes, some prototyping software, HTML page, actual code. Use whatever you feel most comfortable fastest with. In this case the webpage seems pretty trivial so there is no need for paper mock-ups or wireframes. We can go directly to HTML or code.</p>
	</section>
</section>
		<section>
	<h2>First prototype</h2>

	<vcs repo="https://github.com/loov/timeclock" sha="3e1add335e723017366d5ff0e5c66dfab44a98a2"></vcs>

	<p>In the previous chapter we created a sketch of data structures that we might need. Let us convert it into code.</p>

	<p>Our first qestion should be: "What are the most valuable pieces from: <c>Resource</c>, <c>Customer</c>, <c>Worker</c>, <c>Project</c>, <c>Task</c>, <c>Expense</c>, <c>Comment</c>, <c>Attachment</c>?"</p>

	<p>We should pick some of them that we can maintain in our heads at the same time. It should stay between 3-6. 1-2 items at a time can give you tunnel vision with regards to integrating different pieces. More than 6, it becomes impossible to keep all the pieces in your head together.</p>

	<p>The main goal of the program is to track projects. So, I would pick <c>Project</c>, <c>Task</c>, <c>Resource</c> and <c>Expense</c> as our first iteration.</p>

	<section>
		<h3>Project</h3>

		<p>We start with describing the project information:
			<figure><pre>type Project struct {
	Title       string
	Customer    string //TODO: ref
	Pricing     Pricing
	Description string
	Status      Status
}

type Status string

const (
	Queued     Status = &#34;Queued&#34;
	InProgress        = &#34;In Progress&#34;
	Done              = &#34;Done&#34;
	Delivered         = &#34;Delivered&#34;
)

//TODO: is there a better name for this?
type Pricing struct {
	Hours float64
	Price float64
}

type Task struct {
	Title       string
	Description string
	Status      Status
}
</pre></figure>
		</p>

		<p>You may notice we have replaced proper references to other identifiers and items with a simple string. This helps us bootstrap things faster. That way we don't have to think about many things.</p>
	</section>

	<section>
		<h3>Resource</h3>

		<p>For the resource we try to write the minimal and guessing how some things should be represented:
			<figure><pre>type Resource struct {
	Name string
	Unit Unit
	PPU  float64 // price per unit
}

type Expense struct {
	Worker   string //TODO: ref
	Date     time.Time
	Resource Resource
	Units    float64
	Price    float64
}

type Unit string

const (
	Litre = &#34;l&#34;
	Grams = &#34;g&#34;
	Piece = &#34;&#34;
)
</pre></figure>
		</p>

		<p>I was also thinking whether to separate <c>Resource</c> into a package or not. There might be some resource management needed and more complicated logic. If we need, we can always make one.</p>
	</section>
</section>
		<section>
	<h2>Server</h2>
	<vcs repo="https://github.com/loov/timeclock" sha="c420b57de35a12d2ce78c63cf24c030927bccb5b"></vcs>

	<p>Now that we have represented the <c>Project</c> we should try to expose it. This means having a server and frontend.</p>

	<p>For the server we shall go with the standard http library and for the frontend with plain-old-HTML. We should use JavaScript minimally in this project because the users are likely to have older browsers and this will make the implementation more likely to work on any platform.</p>

	<section>
		<h3>Setup</h3>

		<p>I'm going with my usual server setup in <file>main.go</file>:
			<figure><pre>package main

import (
	&#34;flag&#34;
	&#34;net/http&#34;
	&#34;os&#34;
)

var (
	addr = flag.String(&#34;listen&#34;, &#34;:8000&#34;, &#34;http server `address`&#34;) //#1#
)

func main() {
	flag.Parse()

	host, port := os.Getenv(&#34;HOST&#34;), os.Getenv(&#34;PORT&#34;) //#2#
	if host != &#34;&#34; || port != &#34;&#34; {
		*addr = host + &#34;:&#34; + port
	}

	assets := http.FileServer(http.Dir(&#34;assets&#34;))
	http.Handle(&#34;/assets/&#34;, http.StripPrefix(&#34;/assets/&#34;, assets)) //#3#

	http.HandleFunc(&#34;/&#34;, index) //#4#

	log.Println(&#34;Starting server on&#34;, *addr)
	http.ListenAndServe(*addr, nil)
}

func index(w http.ResponseWriter, r *http.Request) {
	http.ServeFile(w, r, &#34;index.html&#34;)
}
</pre><div class="caption">main.go</div></figure>
		</p>

		<p>We add <var at="1">addr</var> to allow configuring the listen address. We override <var at="2"></var> the configuration from environment variables - this way I can use <span class="link" href="https://github.com/codegangsta/gin">gin</span> to automatically recompile the server. We serve <var at="3">assets</var> for any static files, such as css. We show a simple <var at="4">index.html</var> page to see whether our server actually works as intended.</p>

		<p><file>index.html</file> contains nothing special:
		<figure><pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;meta charset=&#34;utf-8&#34;&gt;
	&lt;meta http-equiv=&#34;X-UA-Compatible&#34; content=&#34;IE=edge&#34;&gt;
	&lt;title&gt;Timeclock&lt;/title&gt;
	&lt;link rel=&#34;stylesheet&#34; href=&#34;/assets/css/main.css&#34;&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;h1&gt;Timeclock&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre><div class="caption">index.html</div></figure></p>

		<p><file>main.css</file> contains a minimal html reset:
		<figure><pre>* {
	box-sizing: border-box;
}

body, html {
	margin: 0;
	padding: 0;
	color: #333;

	letter-spacing: 0.02em;

	-ms-word-wrap: break-all;
	word-wrap: break-word;
	-webkit-font-smoothing: antialiased;
}
</pre></figure></p>

		<p>The basic html/css setup might vary. You could use some standard css setup such as <span class="link" href="http://getskeleton.com/">skeleton.css</span> or <span class="link" href="http://getbootstrap.com/">bootstrap</span>, to speed up your workflow.</p>
		<p>We test our server with <cmd>gin .</cmd> and see whether <c>localhost:3000</c> shows something.</p>
	</section>

	<section>
		<h3>Viewing project info</h3>

		<vcs repo="https://github.com/loov/timeclock" sha="4ef17bc635874534b6474f73384bcabb403bf9b2"></vcs>

		<p>After we ensure that the server is working, we make the page show some mock project information. We convert server to use <c>html/template</c>.</p>

		<p>We also add a function to handle any internal errors... note it should use minimally anything that we build. Otherwise, if we use a broken thing to display broken thing we might cause very severe errors.</p>

		<figure><pre>func internalError(w http.ResponseWriter, r *http.Request, err error) {
	message := template.HTMLEscapeString(err.Error())
	page := fmt.Sprintf(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;meta charset=&#34;utf-8&#34;&gt;
	&lt;meta http-equiv=&#34;X-UA-Compatible&#34; content=&#34;IE=edge&#34;&gt;
	&lt;title&gt;Timeclock&lt;/title&gt;
	&lt;link rel=&#34;stylesheet&#34; href=&#34;/assets/css/main.css&#34;&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;div class=&#34;error&#34;&gt;%s&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`, message)
	w.WriteHeader(http.StatusInternalServerError)
	w.Write([]byte(page))
}

func index(w http.ResponseWriter, r *http.Request) {
	t, err := template.ParseFiles(&#34;index.html&#34;)
	if err != nil {
		log.Printf(&#34;error parsing template: %v&#34;, err)
		internalError(w, r, err)
		return
	}

	example := &amp;project.Project{
		Title:    &#34;Alpha&#34;,
		Customer: &#34;ACME&#34;,
		Pricing: project.Pricing{
			Hours: 480,
			Price: 1000,
		},
		Description: &#34;Implement views&#34;,
		Status:      project.InProgress,
	}

	err = t.Execute(w, example)
	if err != nil {
		log.Printf(&#34;error parsing template: %v&#34;, err)
		internalError(w, r, err)
		return
	}
}
</pre><div class="caption">main.go</div></figure>

		<p>We also adjust the <file>index.html</file> to use project information:
			<figure><pre>&lt;div class=&#34;project&#34;&gt;
	&lt;div class=&#34;title&#34;&gt;{{.Title}}&lt;/div&gt;
	&lt;table class=&#34;info&#34; border=&#34;0&#34;&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;b&gt;Customer&lt;/b&gt;&lt;/td&gt;&lt;td&gt;{{.Customer}}&lt;/td&gt;
			&lt;td class=&#34;description&#34; rowspan=&#34;4&#34;&gt;{{.Description}}&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;&lt;td&gt;&lt;b&gt;Status&lt;/b&gt;&lt;/td&gt;&lt;td&gt;{{.Status}}&lt;/td&gt;&lt;/tr&gt;
		&lt;tr&gt;&lt;td&gt;&lt;b&gt;Hours&lt;/b&gt;&lt;/td&gt;&lt;td&gt;{{.Pricing.Hours}}&lt;/td&gt;&lt;/tr&gt;
		&lt;tr&gt;&lt;td&gt;&lt;b&gt;Price&lt;/b&gt;&lt;/td&gt;&lt;td&gt;{{.Pricing.Price}}€&lt;/td&gt;&lt;/tr&gt;
	&lt;/table&gt;
&lt;/div&gt;
</pre></figure>
		</p>

		<p>We also made some adjustments to the .css to make it look nicer.</p>

		<figure><img src="programming/timeclock/images/project-info-00.png"><caption>Project View 00</caption></figure>

		<p>Then we add a way to view expenses:</p>

		<figure><img src="programming/timeclock/images/project-info-01.png"><caption>Project View 01</caption></figure>

		<p>Before proceeding we can ask users whether this is what they were looking for. This is so we can understand whether we are on the right track.</p>
	</section>
</section>
		<section>
	<h2>Feedback #1</h2>

	<p>After remotely showing the first prototype to a user, he gave some
	feedback and sketched out some other views.</p>

	<figure><img src="programming/timeclock/images/feedback-00-worker-view.png"><caption>Worker View</caption></figure>
	<figure><img src="programming/timeclock/images/feedback-00-worker-view.png"><caption>Worker Project View</caption></figure>
	<figure><img src="programming/timeclock/images/feedback-00-customer-view.png"><caption>Customer View</caption></figure>
	<figure><img src="programming/timeclock/images/feedback-00-customer-project-view.png"><caption>Customer Project View</caption></figure>
	<figure><img src="programming/timeclock/images/feedback-00-customer-project-view.png"><caption>Customer Project Date View</caption></figure>

	<p>They also said that the "Project Date View" should contain a place for comments and discussion and that when the project has fixed pricing, then the <c>Customer</c> shouldn't be able to view how many hours workers worked.</p>

	<p>From these views we can deduce several things. First merging resource use and worker work-time into a single thing isn't probably a good idea. It will be better if we break it up.</p>

	<section>
		<h3>Adjusting models</h3>

		<vcs repo="https://github.com/loov/timeclock" sha="e165e7904fcad53d98b2f7707f713763372255fa"></vcs>

		<p>One of the things that can be seen that the "sub-project" idea doesn't figure that much. Maybe we should remove <c>Task</c> for now and later re-add it.</p>

		<p>We also split the <c>Expense</c> into two separate items:
		<figure><pre>type Activity struct {
	Worker   string    //TODO: ref
	Date     time.Time // when was the entry made
	Name string
	Start    time.Time
	Finish   time.Time
	Comment  string
}

func (a *Activity) Total() time.Duration {
	return a.Finish.Sub(a.Start)
}

type Material struct {
	Worker   string //TODO: ref
	Date     time.Time
	Resource Resource
	Units    float64
}

func (m *Material) Total() float64 {
	return m.Resource.PPU * m.Units
}
</pre></figure></p>

		<p>One of the things we may notice here is that these things require some amount of meta-information about the entry. This means we should remove the common items:
			<figure><pre>type Event struct {
	Worker string
	Date   time.Time
}

type Activity struct {
	Event
// ...

type Material struct {
	Event
	Resource Resource
// ...
</pre></figure>
		</p>

		<p>We will adjust the server code accordingly:
			<figure><pre>example := &amp;project.Project{
	Title:    &#34;Alpha&#34;,
	Customer: &#34;ACME&#34;,
	Pricing: project.Pricing{
		Hours: 480,
		Price: 1000,
	},
	Description: &#34;Implement views&#34;,
	Status:      project.InProgress,
}

activites := []*project.Activity{
	{
		Event: project.Event{
			Worker: &#34;John&#34;,
			Date:   time.Now(),
		},
		Name:    &#34;Welding&#34;,
		Start:   time.Now().Add(-2 * time.Hour),
		Finish:  time.Now().Add(-1 * time.Hour),
		Comment: &#34;A, B, C are done&#34;,
	},
	...
}

materials := []*project.Material{
	{
		Event: project.Event{
			Worker: &#34;John&#34;,
			Date:   time.Now(),
		},
		Resource: project.Resource{ ... },
		Units: 8,
	},
}

err = t.Execute(w, map[string]interface{}{
	&#34;Project&#34;:    example,
	&#34;Activities&#34;: activites,
	&#34;Materials&#34;:  materials,
})
</pre></figure></p>

			<p>One of the things we notice here is that there is a lot of different pieces moving around. It would be beneficial to organize all these different items into a single thing. So we will make <c>project.Info</c>:
				<figure><pre>type Activities []*Activity
type Materials []*Material

type Info struct {
	Project    Project
	Activities Activities
	Materials  Materials
}
</pre></figure></p>

			<p>From the sketches we also see that we need a grouping by day, so we will also add:
				<figure><pre>type DayInfo struct {
	Date       time.Time
	Activities Activities
	Materials  Materials
}

func (info *Info) GroupByDay() []DayInfo {
	// ...
</pre></figure></p>

			<p>Of course we need to update the project view to.</p>
			<figure><img src="programming/timeclock/images/project-info-02.png"><caption>Project View</caption></figure>
	</section>

	<section>
		<h3>Many tables</h3>

		<p>At this point, I'm also thinking whether some sort of abstraction to allow more easily to describe the tables would be beneficial. Currently we have several instances of templates:
			<figure><pre>{{if .Activities}}
&lt;div class=&#34;label&#34;&gt;Activities:&lt;/div&gt;
&lt;table class=&#34;activities&#34;&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;th&gt;Worker&lt;/th&gt;
			&lt;th&gt;Activity&lt;/th&gt;
			&lt;th&gt;Start&lt;/th&gt;
			&lt;th&gt;Finish&lt;/th&gt;
			&lt;th&gt;Duration&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
{{range .Activities}}
	&lt;tr&gt;
		&lt;td&gt;{{.Worker}}&lt;/td&gt;
		&lt;td&gt;{{.Name}}&lt;/td&gt;
		&lt;td&gt;{{.Start.Format &#34;15:04&#34;}}&lt;/td&gt;
		&lt;td&gt;{{.Finish.Format &#34;15:04&#34;}}&lt;/td&gt;
		&lt;td&gt;{{.Duration}}&lt;/td&gt;
	&lt;/tr&gt;
{{end}}
&lt;/table&gt;
{{end}}
</pre></figure>
		</p>

		<p>Whereas ideally we could do something like:
			<figure><pre>{{ table .Activities
	&#34;Worker&#34;   .Worker
	&#34;Name&#34;     .Name
	&#34;Start&#34;    (.Start.Format &#34;15:04&#34;)
	&#34;Finish&#34;   (.Finish.Format &#34;15:04&#34;)
	&#34;Duration&#34; .Duration
}}
</pre></figure>
		</p>

		<p>I'm not sure how to implement it, but it is something to think about. For now we can implement the tables manually, before finding a way to implement it. It might be faster to do it manually, until we know what features will be necessary in that thing.</p>
	</section>
</section>


		<section>
	<h2>Redesign #1</h2>

	<vcs repo="https://github.com/loov/timeclock" href="014c64ec669407036018948a9ef6e0ebd765a751"></vcs>

	<p>After putting this project on hold, due to other responsibilities. After few weeks I was finally able to meet with a user behind the same desk. The end result of that discussion was a significant drop in complexity.</p>

	<p>The main thing we got out of the discussion was how the workflow of the worker will look like and how he will use the system.</p>

	<p>When the worker starts his day, he will be presented with a screen (quite likely on a mobile device):
		<figure><img src="programming/timeclock/images/redesign-00-start-working.png"><caption>Start Working</caption></figure>
	</p>

	<p>After selecting a project he chooses the activity he is performing:
		<figure><img src="programming/timeclock/images/redesign-00-working.png"><caption>Working</caption></figure>
	</p>

	<p>There he can submit any additional information such as add an image of the progress or report some issue (such as some parts were missing or broken). After completing the task he can either go select another project or finish his day with a Day Report.
		<figure><img src="programming/timeclock/images/redesign-00-day-report.png"><caption>Day Report</caption></figure>
	</p>

	<p>We try to put together the day-report from existing information as much as possible. We cannot simply actively confirm the work, because sometimes a worker might forget to start his timeclock or alternatively he may be somewhere, where there is no internet access. There might also be some adjustments necessary to the hours, either way, this additional reporting step is necessary.</p>

	<p>All those work hours must be reviewed by an engineer, whether they are up to bar,
	or whether they took longer than they should. Engineers review projects and
	every week, rather than every day:
		<figure><img src="programming/timeclock/images/redesign-00-week-review.png"><caption>Week Review</caption></figure>
	</p>

	<sidenote><p>The screen prototypes left out some parts when designing,
	because it was easy to imagine them being there, but the exact design
	and mock-up wasn't important at that point.</p></sidenote>

	<p>Since all the reviews, whether accepted or declined, need to be processed by
	the accounting, there is also a way to view all the pending/accepted/declined
	week reviews.
		<figure><img src="programming/timeclock/images/redesign-00-weekly-reports.png"><caption>Weekly Reports</caption></figure>
	</p>

	<p>This new approach is much simpler for the workers to work with and easier to implement, while mostly delivering the same amount or even more value.</p>

	<p>The main thing that was removed, was "materials" tracking. It would be inconvenient
	to continously track the materials missing and used, it's easier to do that with talking.</p>

	<p>One thing that I additionally created was a "notes.txt" file, to track things that need to be implemented, however not vital at this point. For example, it contains that there needs to be few statistics pages to get an overview of projects.</p>

	<section>
		<h3>Restart</h3>

		<p>Now we are going to throw away our initial design because it was too complicated. You might be thinking:
		<div class="quote"><div class="text">Wait, what? This is a book about how to write more efficiently and and get things better and now after writing dedicating a chapter on designing something we are just going to throw away all of that work?</div></div></p>

		<p>Let's step back and look at how much we actually have written code:
			<figure><pre>extension  files binary blank code
----------------------------------
go             3      0    41  231
html           1      0     2   91
css            1      0    21   89
</pre></figure>
		</p>

		<p>This is very little code. It can easily be rewritten in a day. Of course, rewriting code is much easier, which means it will go much quicker than first time.</p>

		<p>This book could have started with the "perfect approach", but this is what will happen in real-life: you misunderstand people, you find better ways of doing things and you learn more about the *value* while writing the project.</p>

		<p>Also, it is not wasted effort, the initial design helped to learn about the project. The analysis part was important, not the code part. Without this, we may have never been able to improve the user experience.</p>

		<p>This is also one of the main reasons for holding off stiffening (eg. writing tests) for later, until we are convinced that we have a nice architecture in place for the system to work as a whole.</p>

		<p>This doesn't mean every time you find a better way to implement things, you should rewrite everything. In this case it made more sense to throw previous away and start again.</p>
	</section>

	<section>
		<h3>Architecture</h3>

		<p>Now we have a clearer understanding how the Value is provided to the end-user, how people will use the software. Now is the time to capture this in code.</p>

		<p>First few ideas for the main folder structure:
			<figure><pre>assets
dayreport  // for a workers daily report
project    // for project information
tracking   // tracking workers daily work
user       // user information and permissions
workreview // review of work done
</pre></figure>
		</p>

		<p>Alternatively:
			<figure><pre>assets
project
	tracking
	report
		work
		day
user
</pre></figure>
		</p>

		<p>The second one seems more organized, but we are not trying to "organize", we are trying to capture what the program does and what is important.</p>

		<p>If you had to ask which of those is more like the program seen from the end-user perspective, then I would say the first one. Even though the second one looks cleaner and more-organized.</p>

		<p>Once the end-user perspective changes, then we would adjust as necessary. For example, if we eventually did have many different "reports", then we could refactor it into:
			<figure><pre>assets
project
tracking
reports
	workreport
	dayreview
	workstats
	...
user
</pre></figure>
		</p>

		<p>
		It's enticing to start with this, but this would mean we need a generic way of registering/removing different reports. Also pages to list reports, integrate them with the page routing etc. A lot of new features and we would deliver something valuable slower.
		</p>
	</section>
</section>
	</toc>
</section>
		<section>
	<h1>Spector</h1>
</section>
		<section>
	<h1>Wiki</h1>
</section>
	</toc>
</section></body></html>